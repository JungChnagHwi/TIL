## 파이썬 기초
- 2진수 0b  bin()
- 8진수 0o  oct()
- 16진수 0x  hex()
- 0.1 은 근삿값,, 1.2-1.1=0.09999999987/3.2-3.1=0.1000000000009
- import math, math.isclose(a,b) a와b는 같은 걸로 보자 ,, is가 붙으면 True&False 형식 약속
- sequence type - str,list,tuple,range
- slicing 특정 부분의 값을 추출,, [1:2] 이런거,, slicing 출력은 범위 넘어도 출력 가능,, A[1:3:a] a만큼 건너뛰어 출력
- \n 줄바꿈, \t 탭, \\ 백슬래시, \' 작은따옴표, \" 큰따옴표
- f-스트링 = '{}{}{}'.format(a,b,c) = '%s %d %s' % (a, b, c)
- 집합의 계산: | 합집합, - 차집합, & 교집합
- 암시적 형변환 : 3+5.0=8,,, True+3=4,, True+False=1, 0이 아닌 수는 True
- 비교연산자 : 2.0 is 2 = False 래퍼런스(주소)를 비교해서

## 파이썬 함수
- 내장 함수 import 없이 사용 가능 ex) print는 출력,, return은 반환값 + 종료
- 매개변수:함수를 정의할 때 함수가 받을 값을 나타내는 변수
- 인자:함수를 호출할 때, 실제로 전달되는 값, 반드시 입력&전달
- def a(x,y): 어쩌구, a(특정값, 특정값) -> x,y는 매개, 특정값이 인자
- 기본값 할당 def a(x, y=30): 이러면 a(특정값) 이러면 y=30으로 출력-기본인자
- a(y=특, x=특) 되고 a(y=특, '특') 은 안됨,,모든매개변수에입력필수-키워드 인자(디폴트 값 변경할 때 유용 ex) print(sep='' ,end=''))
- def a(*x):  *붙이면 튜플로 들어감, 매개변수 몇 개인지 모를 때 모두 하나의 변수에 할당-가변인자
- **x 이면 정해지지 않은 키워드 인자 ,, dictionay 형태로 {x:특, y:특} 나옴
- 위치/ 기본/ 가변 / 키워드 / 가변 키워드 - 인자 권장순서
- scope 공간&번위,,,내부는 local, 외부는 global,,만약 local에 값이 없으면 상위 값을 찾아간다.,, n=[1,2,3] 글로벌을 local에서 바꿀 수 있음 리스트라서 가능? 
- local(1함수 안 함수의 변수) -> Enclosed(1의 함수) -> global -> built in(파이썬 그 자체.py,) , local 부터 찾자, ppt예시 확인!!
- iterable:반복가능한 객체
- zip(*iterables) : 같은 인덱스를 튜플로 묶어서 출력(list달아), [(a,b), (a1,b1)]
- lambda 이름 없은 함수, m=list(map(lambda x: x*2, m)) 이렇게 쓰면 좋아
- 패킹 p=1, 2, 3 튜플로 묶어줌,, n[1,2,3,4,5], a,*b,c -> b=[2,3,4]
- 언패킹 p=1,2,3,4,5/ a,b,c,d,e=p-> a=1,b=2,c=3....
- 경로 다른 x.py에 만들어 놓은 함수를 import x 로 부르고 x.함수 들고와서 쓸 수 있어
- 패키지(파일임), 패키지랑 모듈이랑 함수 불러와서 쓰기??
- sorted(num, key=lambda x: x['가])
- continue 다음 반복으로 되돌아가서 건너띄기
- list comprehension > list(expression for 변수 in iterable if 조건식)
- if-else-for 가능, elif 안됨, if중첩 가능
- 리스트를 생성하는 3가지 방법,, for loop, map, list comprehension
- pass, 미완성 코드 지나가기
- enumerate(iterable, start=0),, index 0부터 부여, 튜플로 저장

- error, 
SyntaxError: 구문 에러는 코드의 문법적인 오류로 인해 발생하는 에러
ZeroDivisionError: 0으로 나누기 시도할 때 발생합니다.
TypeError: 잘못된 데이터 타입을 사용할 때 발생합니다.
NameError: 정의되지 않은 변수를 사용할 때 발생합니다.
ValueError: 유효한 값이 아닌 경우 발생합니다.
IndexError: 유효하지 않은 인덱스를 사용할 때 발생합니다.
KeyError: 딕셔너리에서 존재하지 않는 키를 사용할 때 발생합니다.
FileNotFoundError: 파일을 찾을 수 없을 때 발생합니다.

- 언어
인터프리터 언어(Interpreted Language):
소스 코드를 한 줄씩 읽어들여서 바로 실행하는 언어입니다.
코드 실행을 위해 별도의 컴파일 단계가 필요하지 않습니다.
소스 코드를 읽으면서 동시에 번역하고 실행하기 때문에 개발과 디버깅이 편리합니다.
예시: 파이썬, 자바스크립트

컴파일러 언어(Compiled Language):
소스 코드를 기계어로 번역하는 컴파일 단계(시간 소요)를 거쳐서 실행 파일을 생성합니다.
컴파일 단계에서 오류를 발견하고 빠르게 최적화할 수 있습니다.
생성된 실행 파일을 이용하여 반복적으로 실행하므로 실행 속도가 빠릅니다.
예시: C, C++, 자바

어셈블리 언어(Assembly Language):
기계어와 1:1 대응하는 언어로, 사람이 이해하기 쉽도록 기호와 심볼을 사용합니다.
어셈블리어는 기계어로 직접 변환됩니다.
주로 하드웨어와 직접 상호작용하는 시스템 프로그래밍에 사용됩니다.
예시: x86 어셈블리, ARM 어셈블리

기계어(Machine Language):
컴퓨터가 직접 이해하고 실행할 수 있는 0과 1로 구성된 이진 코드입니다.
프로세서가 직접 이해하며 실행합니다.
컴퓨터 아키텍처에 따라 다른 기계어가 존재합니다.

<<<<<<< HEAD
이렇게 다른 종류의 언어들은 각자의 특징과 용도에 따라 프로그램 개발에 사용됩니다. 인터프리터 언어는 개발이 빠르고 편리하며, 컴파일러 언어는 빠른 실행 속도와 최적화를 갖고 있습니다. 어셈블리 언어와 기계어는 하드웨어 접근이 필요한 상황에서 사용되며, 직접적으로 기계와 상호작용할 수 있습니다.
=======
이렇게 다른 종류의 언어들은 각자의 특징과 용도에 따라 프로그램 개발에 사용됩니다. 인터프리터 언어는 개발이 빠르고 편리하며, 컴파일러 언어는 빠른 실행 속도와 최적화를 갖고 있습니다. 어셈블리 언어와 기계어는 하드웨어 접근이 필요한 상황에서 사용되며, 직접적으로 기계와 상호작용할 수 있습니다.


## 데이터 구조
- 메서드?? - 객체에 속한 함수, 위치가 class 내부에서 정의되는 함수, ex) 
- print(n.sort()) #None
>>>>>>> e45505bed3ca2340e8dda99fcdddecaabe55d1d4
